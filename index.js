require("dotenv").config();
const express = require('express');
const cors = require("cors");
const axios = require('axios');

const port = process.env.PORT || 5000;
let LARK_ACCESS_TOKEN = ""; // L∆∞u token to√†n c·ª•c

const app = express();

const allowedOrigins = [
    "http://localhost:5173",
    "https://form-question-ave.vercel.app",
    "https://naturalcleansingae.com/",
    "https://www.naturalcleansingae.com/"
];

app.use(cors({
    origin: function (origin, callback) {
        if (!origin || allowedOrigins.includes(origin)) {
            callback(null, true);
        } else {
            callback(new Error("Not allowed by CORS"));
        }
    },
    methods: ["GET", "POST", "PUT", "DELETE"],
    allowedHeaders: ["Content-Type", "Authorization"],
    credentials: true
}));


// Middleware ƒë·ªÉ parse body request th√†nh JSON
app.use(express.json());

async function fetchLarkToken() {
    try {
        const response = await axios.post(process.env.LARK_URL_GET_TOKEN, {
            app_id: process.env.LARK_APP_ID,
            app_secret: process.env.LARK_APP_SECRET
        });

        LARK_ACCESS_TOKEN = response.data.tenant_access_token;
    } catch (error) {
        console.error("L·ªói l·∫•y token:", error.response?.data || error.message);
    }
}

// üìå G·ªçi token ngay khi server kh·ªüi ƒë·ªông & t·ª± ƒë·ªông l√†m m·ªõi m·ªói 1h50 ph√∫t
(async function startTokenRefresh() {
    await fetchLarkToken();
    setInterval(fetchLarkToken, 1000 * 60 * 110); // 110 ph√∫t (1h50 ph√∫t)
})();

// üìå API proxy ƒë·ªÉ g·ªçi Lark API
app.post("/api/lark-data", async (req, res) => {
    try {
        const response = await sendLarkRequest(req.body.fields);
        res.status(response.status).json(response.data);
    } catch (error) {
        res.status(error.response?.status || 500).json({
            message: "Error calling Lark API",
            error: error.response?.data || error.message
        });
    }
});

// üìå H√†m g·ª≠i request t·ªõi Lark, t·ª± ƒë·ªông c·∫≠p nh·∫≠t token n·∫øu h·∫øt h·∫°n
async function sendLarkRequest(fields) {
    try {
        return await axios.post(
            `https://open.larksuite.com/open-apis/bitable/v1/apps/${process.env.LARK_APP_TOKEN}/tables/${process.env.LARK_TABLE_ID}/records`,
            { fields },
            {
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${LARK_ACCESS_TOKEN}`
                }
            }
        );
    } catch (error) {
        // üìå N·∫øu token h·∫øt h·∫°n (code: 99991663), l·∫•y token m·ªõi r·ªìi th·ª≠ l·∫°i
        if (error.response?.data?.code === 99991663) {
            await fetchLarkToken();
            return sendLarkRequest(fields); // G·ªçi l·∫°i request sau khi c√≥ token m·ªõi
        }
        throw error;
    }
}

app.post("/api/lark-data-not-complete", async (req, res) => {
    try {
        const response = await sendLarkRequestNotComplete(req.body.fields);
        res.status(response.status).json(response.data);
    } catch (error) {
        res.status(error.response?.status || 500).json({
            message: "Error calling Lark API",
            error: error.response?.data || error.message
        });
    }
});

// üìå H√†m g·ª≠i request t·ªõi Lark, t·ª± ƒë·ªông c·∫≠p nh·∫≠t token n·∫øu h·∫øt h·∫°n
async function sendLarkRequestNotComplete(fields) {
    try {
        return await axios.post(
            `https://open.larksuite.com/open-apis/bitable/v1/apps/${process.env.LARK_APP_TOKEN}/tables/${process.env.LARK_TABLE_ID_NOT_COMPLETE}/records`,
            { fields },
            {
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${LARK_ACCESS_TOKEN}`
                }
            }
        );
    } catch (error) {
        // üìå N·∫øu token h·∫øt h·∫°n (code: 99991663), l·∫•y token m·ªõi r·ªìi th·ª≠ l·∫°i
        if (error.response?.data?.code === 99991663) {
            await fetchLarkToken();
            return sendLarkRequest(fields); // G·ªçi l·∫°i request sau khi c√≥ token m·ªõi
        }
        throw error;
    }
}

const shopifyAPI = `https://${process.env.SHOPIFY_STORE}/admin/api/2024-01/customers.json`;
const LARK_API = `https://open.larksuite.com/open-apis/bitable/v1/apps/${process.env.LARK_APP_TOKEN}/tables/${process.env.LARK_TABLE_ID_CUSTOMERS}/records`;

const getCustomers = async () => {
    try {
        const response = await axios.get(shopifyAPI, {
            headers: {
                'X-Shopify-Access-Token': process.env.SHOPIFY_ACCESS_TOKEN,
                'Content-Type': 'application/json',
            },
        });
        return response.data.customers;
    } catch (error) {
        console.error('L·ªói khi g·ªçi Shopify API:', error.response?.data || error.message);
    }
};

const checkCustomerExistsInLarkBase = async (customerId) => {
    try {
        // L·∫•y t·∫•t c·∫£ c√°c records trong b·∫£ng LarkBase
        const response = await axios.get(
            `${LARK_API}`,  // C·∫≠p nh·∫≠t v·ªõi ƒë∆∞·ªùng d·∫´n l·∫•y d·ªØ li·ªáu
            {
                headers: {
                    Authorization: `Bearer ${LARK_ACCESS_TOKEN}`,
                    'Content-Type': 'application/json',
                },
            }
        );

        // Ki·ªÉm tra n·∫øu d·ªØ li·ªáu tr·∫£ v·ªÅ c√≥ b·∫£n ghi ch·ª©a customer_id
        const customerExists = response.data.data.items.some((record) => {
            return record.fields.customer_id === customerId
        });

        return customerExists;  // Tr·∫£ v·ªÅ true n·∫øu t·ªìn t·∫°i, false n·∫øu kh√¥ng
    } catch (error) {
        console.error('‚ùå L·ªói khi ki·ªÉm tra kh√°ch h√†ng t·ªìn t·∫°i:', error.response?.data || error.message);
        return true;  // M·∫∑c ƒë·ªãnh l√† kh√¥ng t·ªìn t·∫°i n·∫øu c√≥ l·ªói
    }
};

const formatCustomersForLarkBase = (customer) => {
    return {
        "customer_id": customer.id.toString(),
        "first_name": customer.first_name || "",
        "last_name": customer.last_name || "",
        "email": customer.email || "",
        "phone": customer.phone || "",
        "created_at": customer.created_at || "",
        "orders_count": customer.orders_count || 0,
        "total_spent": customer.total_spent || "",
        "address": customer.default_address
            ? `${customer.default_address.address1}, ${customer.default_address.city}, ${customer.default_address.country}`
            : ""
    };
};

const syncToLarkBase = async (customers) => {
    if (!customers.length) {
        console.log('‚ö†Ô∏è Kh√¥ng c√≥ kh√°ch h√†ng n√†o ƒë·ªÉ ƒë·ªìng b·ªô.');
        return;
    }

    try {
        for (let customer of customers) {
            let formattedData = formatCustomersForLarkBase(customer); // Chuy·ªÉn ƒë·ªïi m·ªói customer th√†nh m·∫£ng 1 ph·∫ßn t·ª≠
            // Ki·ªÉm tra xem kh√°ch h√†ng ƒë√£ t·ªìn t·∫°i trong LarkBase ch∆∞a
            const exists = await checkCustomerExistsInLarkBase(formattedData.customer_id);
            if (exists) {
                console.log(`üîç Kh√°ch h√†ng v·ªõi ID ${formattedData.customer_id} ƒë√£ t·ªìn t·∫°i trong LarkBase. Kh√¥ng th√™m m·ªõi.`);
                continue;  // N·∫øu kh√°ch h√†ng ƒë√£ t·ªìn t·∫°i, b·ªè qua v√† kh√¥ng th√™m v√†o n·ªØa
            }

            //N·∫øu kh√°ch h√†ng ch∆∞a t·ªìn t·∫°i, ti·∫øn h√†nh ƒë·ªìng b·ªô
            let response = await axios.post(
                LARK_API,
                { fields: formattedData },  // ƒê·∫£m b·∫£o s·ª≠ d·ª•ng 'records'
                {
                    headers: {
                        Authorization: `Bearer ${LARK_ACCESS_TOKEN}`,
                        'Content-Type': 'application/json',
                    },
                }
            );
        }
    } catch (error) {
        console.error('‚ùå L·ªói khi ƒë·ªìng b·ªô v·ªõi LarkBase:', error.response?.data || error.message);
        if (error.response?.data?.error?.field_violations) {
            console.error('L·ªói chi ti·∫øt tr∆∞·ªùng:', error.response.data.error.field_violations);
        }
    }
};

// üöÄ Ch·∫°y h√†m ƒë·ªìng b·ªô m·ªói 24 gi·ªù
const syncCustomersEvery24Hours = () => {
    // T·∫°o m·ªôt interval ƒë·ªÉ g·ªçi h√†m ƒë·ªìng b·ªô m·ªói 24 gi·ªù (24 * 60 * 60 * 1000 milliseconds)
    setInterval(async () => {
        console.log('üöÄ B·∫Øt ƒë·∫ßu ƒë·ªìng b·ªô kh√°ch h√†ng...');
        const customers = await getCustomers();  // L·∫•y danh s√°ch kh√°ch h√†ng t·ª´ Shopify
        await syncToLarkBase(customers);  // ƒê·ªìng b·ªô v·ªõi LarkBase
        console.log('‚úÖ ƒê·ªìng b·ªô ho√†n th√†nh!');
    }, 24 * 60 * 60 * 1000);  // 24 gi·ªù = 24 * 60 * 60 * 1000 milliseconds
};

// G·ªçi h√†m ƒë·ªÉ b·∫Øt ƒë·∫ßu ƒë·ªìng b·ªô t·ª± ƒë·ªông
syncCustomersEvery24Hours();


// üìå ƒê·ªìng b·ªô s·∫£n ph·∫©m
const shopifyAPIProduct = `https://${process.env.SHOPIFY_STORE}/admin/api/2024-01/products.json`;
const LARK_API_PRODUCT = `https://open.larksuite.com/open-apis/bitable/v1/apps/${process.env.LARK_APP_TOKEN}/tables/${process.env.LARK_TABLE_ID_PRODUCTS}/records`;

const getProducts = async () => {
    try {
        const response = await axios.get(shopifyAPIProduct, {
            headers: {
                'X-Shopify-Access-Token': process.env.SHOPIFY_ACCESS_TOKEN,
                'Content-Type': 'application/json',
            },
        });
        return response.data.products;
    } catch (error) {
        console.error('L·ªói khi g·ªçi Shopify API:', error.response?.data || error.message);
    }
};

const checkProductExistsInLarkBase = async (products_id) => {
    try {
        // L·∫•y t·∫•t c·∫£ c√°c records trong b·∫£ng LarkBase
        const response = await axios.get(
            `${LARK_API_PRODUCT}`,  // C·∫≠p nh·∫≠t v·ªõi ƒë∆∞·ªùng d·∫´n l·∫•y d·ªØ li·ªáu
            {
                headers: {
                    Authorization: `Bearer ${LARK_ACCESS_TOKEN}`,
                    'Content-Type': 'application/json',
                },
            }
        );

        const customerExists = response.data.data.items.some((record) => {
            return record.fields.products_id === products_id
        });

        return customerExists;  // Tr·∫£ v·ªÅ true n·∫øu t·ªìn t·∫°i, false n·∫øu kh√¥ng
    } catch (error) {
        console.error('‚ùå L·ªói khi ki·ªÉm tra s·∫£n ph·∫©m t·ªìn t·∫°i:', error.response?.data || error.message);
        return true;  // M·∫∑c ƒë·ªãnh l√† kh√¥ng t·ªìn t·∫°i n·∫øu c√≥ l·ªói
    }
};

const formatProductsForLarkBase = (product) => {
    return {
        "products_id": product.id.toString(),
        "title": product.title || "",
        "status": product.status || "",
        "created_at": product.created_at || "",
    };
};

const syncToLarkBaseProduct = async (products) => {
    if (!products.length) {
        console.log('‚ö†Ô∏è Kh√¥ng c√≥ s·∫£n ph·∫©m n√†o ƒë·ªÉ ƒë·ªìng b·ªô.');
        return;
    }

    try {
        for (let product of products) {
            let formattedData = formatProductsForLarkBase(product);
            // Ki·ªÉm tra xem kh√°ch h√†ng ƒë√£ t·ªìn t·∫°i trong LarkBase ch∆∞a
            const exists = await checkProductExistsInLarkBase(formattedData.products_id);
            if (exists) {
                console.log(`üîç S·∫£n ph·∫©m v·ªõi ID ${formattedData.products_id} ƒë√£ t·ªìn t·∫°i trong LarkBase. Kh√¥ng th√™m m·ªõi.`);
                continue;
            }

            await axios.post(
                LARK_API_PRODUCT,
                { fields: formattedData },  // ƒê·∫£m b·∫£o s·ª≠ d·ª•ng 'records'
                {
                    headers: {
                        Authorization: `Bearer ${LARK_ACCESS_TOKEN}`,
                        'Content-Type': 'application/json',
                    },
                }
            );
        }
    } catch (error) {
        console.error('‚ùå L·ªói khi ƒë·ªìng b·ªô v·ªõi LarkBase:', error.response?.data || error.message);
        if (error.response?.data?.error?.field_violations) {
            console.error('L·ªói chi ti·∫øt tr∆∞·ªùng:', error.response.data.error.field_violations);
        }
    }
};

// üöÄ Ch·∫°y h√†m ƒë·ªìng b·ªô m·ªói 24 gi·ªù
const syncProductsEvery24Hours = () => {
    // T·∫°o m·ªôt interval ƒë·ªÉ g·ªçi h√†m ƒë·ªìng b·ªô m·ªói 24 gi·ªù (24 * 60 * 60 * 1000 milliseconds)
    setInterval(async () => {
        console.log('üöÄ B·∫Øt ƒë·∫ßu ƒë·ªìng b·ªô s·∫£n ph·∫©m...');
        const products = await getProducts();
        await syncToLarkBaseProduct(products);
        console.log('‚úÖ ƒê·ªìng b·ªô ho√†n th√†nh!');
    }, 24 * 60 * 60 * 1000);  // 24 gi·ªù = 24 * 60 * 60 * 1000 milliseconds
};

// G·ªçi h√†m ƒë·ªÉ b·∫Øt ƒë·∫ßu ƒë·ªìng b·ªô t·ª± ƒë·ªông
syncProductsEvery24Hours();

// Start server
app.listen(port, () => {
    console.log(`Server is running on port ${port}`);
});
